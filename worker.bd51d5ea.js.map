{"version":3,"sources":["shapes.ts","hsla.ts","manager.ts","message.types.ts","worker.ts"],"names":[],"mappings":";AA0IwB,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,YAAA,QAAA,eAAA,EAxIxB,MAAM,EAAS,CACb,IAAK,GACL,IAAK,KAGD,MAAgB,EA0BpB,YACqB,EACA,EACA,EACnB,GAHmB,KAAA,IAAA,EACA,KAAA,OAAA,EACA,KAAA,SAAA,EAvBb,KAAA,MAAQ,EA0BT,KAAA,EAAI,EAAY,EAChB,KAAA,EAAI,EAAY,EAChB,KAAA,OAAS,EAAY,OACrB,KAAA,MAAQ,EAAY,MA3BpB,cACL,EACA,EACA,GAEI,IAAA,EACA,EASG,OARa,KAAK,SACP,IAChB,EAAQ,EACR,EAAW,EAAI,KAAK,MAAsB,EAAhB,KAAK,YAE/B,EAAQ,EACR,EAAW,EAAI,KAAK,MAAsB,EAAhB,KAAK,WAE1B,IAAI,EAAM,EAAK,EAAQ,EAAU,GAetC,gBACK,OAAA,KAAK,MAAQ,IAGtB,MAAM,GACG,OAAA,IAAI,KAAK,MAAM,KAAK,IAAK,KAAK,OAAQ,KAAK,SAAU,GAG9D,OACO,KAAA,IAAI,YACJ,KAAA,eACA,KAAA,IAAI,UAAY,KAAK,UACrB,KAAA,IAAI,OAEJ,KAAA,IAAI,YACJ,KAAA,kBACA,KAAA,eACA,KAAA,IAAI,YACJ,KAAA,IAAI,SAEJ,KAAA,OAGK,gBACJ,MAAA,EAAQ,KAAK,OAAO,EAAI,KAAK,MACpB,MAAA,QAAA,OAAA,KAAK,OAAO,EAAM,MAAA,OAAA,KAAK,OAAO,EAAM,MAAA,OAAA,KAAK,OAAO,EAAO,OAAA,OAAA,EAAtE,KAGE,iBACK,OAAA,KAAK,MAAQ,IAGd,OACD,KAAA,MAAQ,KAAK,OAAS,GAKrB,kBACD,KAAA,IAAI,YAAqC,uBAAA,OAAA,KAAK,MAAnD,KACK,KAAA,IAAI,UAAY,EAChB,KAAA,IAAI,QAAU,SAoDC,QAAA,UAAA,EAhDxB,MAAM,UAAgB,EAAtB,cAgDwB,SAAA,WA/CH,KAAA,MAAQ,EAEjB,eACJ,IAAA,EAAG,EAAG,EACL,IAAA,IAAI,EAAI,EAAG,EAAI,KAAK,SAAU,GAAK,EACtC,EAAQ,KAAK,MAAS,EAAI,KAAK,GAAK,EAAK,KAAK,SAC9C,EAAI,KAAK,EAAI,KAAK,OAAS,KAAK,IAAI,GACpC,EAAI,KAAK,EAAI,KAAK,OAAS,KAAK,IAAI,GAE1B,IAAN,EACG,KAAA,IAAI,OAAO,EAAG,GAEd,KAAA,IAAI,OAAO,EAAG,IAM3B,MAAM,UAAiB,EAAvB,cA6BwB,SAAA,WA5BH,KAAA,MAAQ,EAEjB,eACF,MAAA,EAAyB,EAAhB,KAAK,SAChB,IAAA,EACA,EACA,EACA,EACC,IAAA,IAAI,EAAI,EAAG,EAAI,EAAQ,GAAK,EAC/B,EAAQ,KAAK,MAAS,EAAI,KAAK,GAAK,EAAK,EAEvC,EADE,EAAI,EACG,GAAM,KAAK,OAEX,KAAK,OAGhB,EAAI,KAAK,EAAI,EAAS,KAAK,IAAI,GAC/B,EAAI,KAAK,EAAI,EAAS,KAAK,IAAI,GAErB,IAAN,EACG,KAAA,IAAI,OAAO,EAAG,GAEd,KAAA,IAAI,OAAO,EAAG,IAMrB,MAAO,EAeX,YAAmB,EAAkB,EAAkB,EAAuB,GAA3D,KAAA,EAAA,EAAkB,KAAA,EAAA,EAAkB,KAAA,OAAA,EAAuB,KAAA,MAAA,EAdvE,eAAQ,EAAW,GACjB,OAAA,IAAI,EAAY,EAAG,EAAG,EAAO,IAAK,GAGpC,oBAAa,EAAW,EAAW,GAClC,MAAA,EAAS,EAAS,EAAI,EACtB,EAAS,EAAS,EAAI,EACtB,EAAS,KAAK,KAAK,EAAS,EAAS,EAAS,GAE9C,EAAS,KAAK,IAAI,KAAK,IAAI,EAAQ,EAAO,KAAM,EAAO,KACvD,EAAQ,KAAK,KAAK,EAAS,GAC1B,OAAA,IAAI,EAAY,EAAG,EAAG,EAAQ,IAZjB,QAAA,YAAA;;ACpGxB,aA/BM,SAAU,EAAkB,EAAW,EAAW,EAAW,GAC7D,IAAA,EAKA,GAJJ,EAAI,EAAiB,KAAK,MAAM,GAAK,IAAK,KAC1C,EAAI,EAAiB,KAAK,MAAM,GAAK,IAAK,KAC1C,EAAI,EAAiB,KAAK,MAAM,GAAK,IAAK,KAEhC,IAAN,EAAS,CACL,MAAA,EAAQ,KAAK,MAAM,KAAK,MAAM,IAAM,IAC1C,EAAO,CACL,EAAG,EACH,EAAG,EACH,EAAG,EACH,EAAG,OAEA,CACC,MAAA,EAAI,EAAI,GAAM,GAAK,EAAI,GAAK,EAAI,EAAI,EAAI,EACxC,EAAI,EAAI,EAAI,EAClB,EAAO,CACL,EAAG,UAA6C,IAAnC,EAAgB,EAAG,EAAG,EAAI,EAAI,IAAU,QAAQ,GAAI,IACjE,EAAG,UAAqC,IAA3B,EAAgB,EAAG,EAAG,IAAU,QAAQ,GAAI,IACzD,EAAG,UAA6C,IAAnC,EAAgB,EAAG,EAAG,EAAI,EAAI,IAAU,QAAQ,GAAI,IACjE,EAAG,GAGA,OAAA,EAGT,SAAS,EAAiB,EAAgB,GACjC,OAAA,EAAS,EAGlB,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,kBAAA,EAAA,IAAI,EAAkB,SAAS,EAAW,EAAW,GAO/C,OANA,EAAI,IACN,GAAK,GAEH,EAAI,IACN,GAAK,GAEH,EAAI,EAAI,EACH,EAAc,GAAT,EAAI,GAAS,EAEvB,EAAI,GACC,EAEL,EAAI,EAAI,EACH,GAAK,EAAI,IAAM,EAAI,EAAI,GAAK,EAE9B;;ACSR,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,aAAA,EA/DD,IAAA,EAAA,QAAA,YACA,EAAA,QAAA,UAEM,MAAO,EAGX,YACU,EACA,EACA,GAFA,KAAA,IAAA,EACA,KAAA,MAAA,EACA,KAAA,OAAA,EALO,KAAA,SAA0C,GAQ3D,YAAY,EAAiB,EAAW,GAChC,MAAA,GAAc,IAAI,MAAO,UACzB,GAAS,EAAkB,EAAA,mBAAA,EAAc,IAAK,IAAK,GAAI,GACvD,EAAc,EAAY,YAAA,QAAQ,EAAG,GACrC,EAAQ,EAAU,UAAA,OAAO,KAAK,IAAK,EAAQ,GAC5C,KAAA,SAAY,GAAA,OAAA,IAAa,CAC5B,OAAQ,CAAC,GACT,gBAAiB,GAIrB,WAAW,EAAiB,EAAW,GAC/B,MAAA,OAAE,EAAF,gBAAU,GAAoB,KAAK,SAAY,GAAA,OAAA,IACjD,IAAC,EACH,OAGI,MAAA,EAAc,EAAY,YAAA,aAAa,EAAG,EAAG,GAC7C,EAAQ,EAAK,GAAQ,MAAM,GACjC,EAAO,KAAK,GACP,KAAA,SAAY,GAAA,OAAA,IAAW,gBAAkB,EAGhD,iBAAiB,EAAe,GACzB,KAAA,MAAQ,EACR,KAAA,OAAS,EAGhB,UACO,KAAA,IAAI,UAAU,EAAG,EAAG,KAAK,MAAO,KAAK,QACrC,IAAA,MAAM,KAAM,KAAK,SAAU,CACxB,MAAA,OAAE,GAAW,KAAK,SAAS,GAC3B,EAA6B,GACnC,EAAO,QAAQ,IACb,EAAM,OACF,EAAM,WACR,EAAc,KAAK,KAGlB,KAAA,SAAS,GAAI,OAAS,IAUjC,SAAS,EAAQ,GACR,OAAA,EAAM,EAAM,OAAS,GAC7B,QAAA,QAAA;;AC/DD,aAAA,IAAkB,EAAlB,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,wBAAA,EAAA,QAAA,mBAAA,EAAA,SAAkB,GAChB,EAAA,EAAA,KAAA,GAAA,OACA,EAAA,EAAA,WAAA,GAAA,aACA,EAAA,EAAA,SAAA,GAAA,WACA,EAAA,EAAA,WAAA,GAAA,aAJF,CAAkB,IAAA,QAAA,mBAAA,EAAkB;;ACkCnC,aAlCD,IAAA,EAAA,QAAA,aACA,EAAA,QAAA,mBAEA,IAAI,EACA,EAyBJ,SAAS,IACP,sBAAsB,KAIvB,IAAA,EAHG,IACO,QAAP,EAAA,SAAO,IAAA,GAAA,EAAE,YA1Bb,UAAY,SAAS,GACb,MAAA,EAAO,EAAM,KACX,OAAA,EAAK,MACN,KAAA,EAAmB,mBAAA,KAEhB,MAAA,GADN,EAAS,EAAK,QACK,WAAW,MAC9B,EAAU,IAAI,EAAJ,QAAY,EAAK,EAAK,MAAO,EAAK,QAC5C,IACA,MACG,KAAA,EAAmB,mBAAA,WACtB,EAAO,MAAQ,EAAK,MACpB,EAAO,OAAS,EAAK,OACrB,EAAQ,iBAAiB,EAAK,MAAO,EAAK,QAC1C,MACG,KAAA,EAAmB,mBAAA,SACtB,EAAQ,YAAY,EAAK,WAAY,EAAK,EAAG,EAAK,GAClD,MACG,KAAA,EAAmB,mBAAA,WACtB,EAAQ,WAAW,EAAK,WAAY,EAAK,EAAG,EAAK","file":"worker.bd51d5ea.js","sourceRoot":"../src","sourcesContent":["import { RGBAColour } from './hsla';\n\nconst RADIUS = {\n  MIN: 10,\n  MAX: 100,\n};\n\nexport abstract class PolyShape {\n  protected readonly x: number;\n  protected readonly y: number;\n  protected readonly radius: number;\n  protected readonly angle: number;\n  protected abstract klass: typeof Polygon | typeof Polystar;\n  private alpha = 1;\n\n  static random(\n    ctx: OffscreenCanvasRenderingContext2D,\n    colour: RGBAColour,\n    coordinates: Coordinates,\n  ): Polygon | Polystar {\n    let shape: typeof Polygon | typeof Polystar;\n    let vertices: number;\n    const styleChoice = Math.random();\n    if (styleChoice < 0.5) {\n      shape = Polygon;\n      vertices = 3 + Math.round(Math.random() * 6);\n    } else {\n      shape = Polystar;\n      vertices = 4 + Math.round(Math.random() * 7);\n    }\n    return new shape(ctx, colour, vertices, coordinates);\n  }\n\n  constructor(\n    protected readonly ctx: OffscreenCanvasRenderingContext2D,\n    protected readonly colour: RGBAColour,\n    protected readonly vertices: number,\n    coordinates: Coordinates,\n  ) {\n    this.x = coordinates.x;\n    this.y = coordinates.y;\n    this.radius = coordinates.radius;\n    this.angle = coordinates.angle;\n  }\n\n  get isVisible(): boolean {\n    return this.alpha > 0.01;\n  }\n\n  clone(coordinates: Coordinates): Polygon | Polystar {\n    return new this.klass(this.ctx, this.colour, this.vertices, coordinates);\n  }\n\n  draw(): void {\n    this.ctx.beginPath();\n    this.drawVertices();\n    this.ctx.fillStyle = this.fillStyle;\n    this.ctx.fill();\n\n    this.ctx.beginPath();\n    this.setStrokeStyles();\n    this.drawVertices();\n    this.ctx.closePath();\n    this.ctx.stroke();\n\n    this.fade();\n  }\n\n  private get fillStyle(): string {\n    const alpha = this.colour.a * this.alpha;\n    return `rgba(${this.colour.r}, ${this.colour.g}, ${this.colour.b} , ${alpha})`;\n  }\n\n  get isFadedOut(): boolean {\n    return this.alpha < 0.01;\n  }\n\n  private fade() {\n    this.alpha = this.alpha *= 0.90;\n  }\n\n  protected abstract drawVertices(): void;\n\n  private setStrokeStyles() {\n    this.ctx.strokeStyle = `rgba(255, 255, 255, ${this.alpha})`;\n    this.ctx.lineWidth = 3;\n    this.ctx.lineCap = 'round';\n  }\n}\n\nclass Polygon extends PolyShape {\n  protected readonly klass = Polygon;\n\n  protected drawVertices() {\n    var x, y, angle;\n    for (let i = 0; i < this.vertices; i += 1) {\n      angle = this.angle + (2 * Math.PI * i) / this.vertices;\n      x = this.x + this.radius * Math.cos(angle);\n      y = this.y + this.radius * Math.sin(angle);\n\n      if (i === 0) {\n        this.ctx.moveTo(x, y);\n      } else {\n        this.ctx.lineTo(x, y);\n      }\n    }\n  }\n}\n\nclass Polystar extends PolyShape {\n  protected readonly klass = Polystar;\n\n  protected drawVertices(): void {\n    const points = this.vertices * 2;\n    let x: number;\n    let y: number;\n    let radius: number;\n    let angle: number;\n    for (let i = 0; i < points; i += 1) {\n      angle = this.angle + (2 * Math.PI * i) / points;\n      if (i % 2) {\n        radius = 0.6 * this.radius;\n      } else {\n        radius = this.radius;\n      }\n\n      x = this.x + radius * Math.cos(angle);\n      y = this.y + radius * Math.sin(angle);\n\n      if (i === 0) {\n        this.ctx.moveTo(x, y);\n      } else {\n        this.ctx.lineTo(x, y);\n      }\n    }\n  }\n}\n\nexport class Coordinates {\n  static initial(x: number, y: number): Coordinates {\n    return new Coordinates(x, y, RADIUS.MIN, 0);\n  }\n\n  static fromPrevious(x: number, y: number, previous: Coordinates): Coordinates {\n    const deltaX = previous.x - x;\n    const deltaY = previous.y - y;\n    const deltaR = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n\n    const radius = Math.min(Math.max(deltaR, RADIUS.MIN), RADIUS.MAX);\n    const angle = Math.atan(deltaX / deltaY);\n    return new Coordinates(x, y, radius, angle);\n  }\n\n  constructor(public x: number, public y: number, public radius: number, public angle: number) {}\n}\n","export interface RGBAColour {\n  r: number;\n  g: number;\n  b: number;\n  a: number;\n}\n\nexport function convertHSLAToRGBA(h: number, s: number, l: number, a: number): RGBAColour {\n  let rgba: RGBAColour;\n  h = convertToPercent(Math.round(h) % 360, 360);\n  s = convertToPercent(Math.round(s) % 101, 100);\n  l = convertToPercent(Math.round(l) % 101, 100);\n\n  if (s === 0) {\n    const value = Math.round(Math.round(255 * l));\n    rgba = {\n      r: value,\n      g: value,\n      b: value,\n      a: a,\n    };\n  } else {\n    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n    const p = 2 * l - q;\n    rgba = {\n      r: parseInt((convertHueToRGB(p, q, h + 1 / 3) * 256).toFixed(0), 10),\n      g: parseInt((convertHueToRGB(p, q, h) * 256).toFixed(0), 10),\n      b: parseInt((convertHueToRGB(p, q, h - 1 / 3) * 256).toFixed(0), 10),\n      a: a,\n    };\n  }\n  return rgba;\n}\n\nfunction convertToPercent(amount: number, limit: number): number {\n  return amount / limit;\n}\n\nvar convertHueToRGB = function(p: number, q: number, t: number): number {\n  if (t < 0) {\n    t += 1;\n  }\n  if (t > 1) {\n    t -= 1;\n  }\n  if (t < 1 / 6) {\n    return p + (q - p) * 6 * t;\n  }\n  if (t < 1 / 2) {\n    return q;\n  }\n  if (t < 2 / 3) {\n    return p + (q - p) * (2 / 3 - t) * 6;\n  }\n  return p;\n};\n","import { PolyShape, Coordinates } from './shapes';\nimport { convertHSLAToRGBA, RGBAColour } from './hsla';\n\nexport class Manager {\n  private readonly dataById: { [id: string]: ManagedItem } = {};\n\n  constructor(\n    private ctx: OffscreenCanvasRenderingContext2D,\n    private width: number,\n    private height: number,\n  ) {}\n\n  addNewShape(shapeId: number, x: number, y: number): void {\n    const currentTime = new Date().getTime();\n    const colour = convertHSLAToRGBA(currentTime % 360, 100, 50, 1);\n    const coordinates = Coordinates.initial(x, y);\n    const shape = PolyShape.random(this.ctx, colour, coordinates);\n    this.dataById[`${shapeId}`] = {\n      shapes: [shape],\n      lastCoordinates: coordinates,\n    };\n  }\n\n  cloneShape(shapeId: number, x: number, y: number): void {\n    const { shapes, lastCoordinates } = this.dataById[`${shapeId}`];\n    if (!shapes) {\n      return;\n    }\n\n    const coordinates = Coordinates.fromPrevious(x, y, lastCoordinates);\n    const shape = last(shapes).clone(coordinates);\n    shapes.push(shape);\n    this.dataById[`${shapeId}`].lastCoordinates = coordinates;\n  }\n\n  updateScreenSize(width: number, height: number): void {\n    this.width = width;\n    this.height = height;\n  }\n\n  drawAll(): void {\n    this.ctx.clearRect(0, 0, this.width, this.height);\n    for (const id in this.dataById) {\n      const { shapes } = this.dataById[id];\n      const visibleShapes: PolyShape[] = [];\n      shapes.forEach(shape => {\n        shape.draw();\n        if (shape.isVisible) {\n          visibleShapes.push(shape);\n        }\n      });\n      this.dataById[id].shapes = visibleShapes;\n    }\n  }\n}\n\nexport interface ManagedItem {\n  shapes: PolyShape[];\n  lastCoordinates: Coordinates;\n}\n\nfunction last<T>(array: T[]): T {\n  return array[array.length - 1];\n}\n","export const enum WorkerMessageTypes {\n  Init,\n  UpdateSize,\n  AddShape,\n  CloneShape,\n}\n","import { Manager } from './manager';\nimport { WorkerMessageTypes } from './message.types';\n\nlet canvas: OffscreenCanvas;\nlet manager: Manager;\n\nonmessage = function(event) {\n  const data = event.data;\n  switch (data.type as WorkerMessageTypes) {\n    case WorkerMessageTypes.Init:\n      canvas = data.canvas;\n      const ctx = canvas.getContext('2d')!;\n      manager = new Manager(ctx, data.width, data.height);\n      tick();\n      break;\n    case WorkerMessageTypes.UpdateSize:\n      canvas.width = data.width;\n      canvas.height = data.height;\n      manager.updateScreenSize(data.width, data.height);\n      break;\n    case WorkerMessageTypes.AddShape:\n      manager.addNewShape(data.identifier, data.x, data.y);\n      break;\n    case WorkerMessageTypes.CloneShape:\n      manager.cloneShape(data.identifier, data.x, data.y);\n      break;\n  }\n};\n\nfunction tick() {\n  requestAnimationFrame(() => {\n    tick();\n    manager?.drawAll();\n  });\n}\n"]}